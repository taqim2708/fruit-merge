<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Meta Tags -->
    <title>Fruit Merge Master ✨ Physics Puzzle</title>
    <meta name="description" content="Play Fruit Merge Master, an addictive physics puzzle game. Merge fruits and reach the watermelon!">
    <meta name="keywords" content="fruit merge, suika game, physics puzzle, web game, casual game">
    <link rel="canonical" href="https://taqim2708.github.io/fruit-merge/">
    
    <!-- Social Media Meta Tags (Open Graph) -->
    <meta property="og:title" content="Fruit Merge Master ✨">
    <meta property="og:description" content="Can you merge your way to the Watermelon?">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://taqim2708.github.io/fruit-merge/">
    
    <style>
        :root {
            --bg-color: #fef9e7;
            --panel-color: #ffffff;
            --accent-color: #5d4037;
            --danger-color: #ff3e3e;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #game-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border-radius: 0 0 12px 12px;
            background: #fff8dc;
            overflow: hidden;
            border: 4px solid var(--accent-color);
            border-top: none;
        }

        .ui-container {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--panel-color);
            padding: 10px 15px;
            border-radius: 12px;
            box-sizing: border-box;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            border: 3px solid var(--accent-color);
        }

        .evolution-guide {
            width: 100%;
            background: var(--panel-color);
            padding: 8px;
            border-radius: 12px;
            border: 3px solid var(--accent-color);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            box-sizing: border-box;
            overflow-x: auto;
        }

        .evolution-item {
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 16px;
        }

        .arrow {
            font-size: 10px;
            color: #aaa;
            font-weight: bold;
        }

        .stat {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 900;
            color: var(--accent-color);
        }

        #next-fruit-preview {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f0f0f0;
            border-radius: 50%;
        }

        #next-fruit-preview img {
            width: 80%;
            height: 80%;
            object-fit: contain;
        }

        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            text-align: center;
            padding: 20px;
        }

        .btn {
            background: #ffcc00;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            color: #333;
            transition: transform 0.2s;
        }

        @media (max-height: 800px) {
            #game-wrapper {
                transform: scale(0.8);
            }
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div class="ui-container">
        <div class="stat">
            <span class="stat-label">Score</span>
            <span id="score" class="stat-value">0</span>
        </div>
        <div class="stat" style="align-items: center;">
            <span class="stat-label">Next</span>
            <div id="next-fruit-preview"></div>
        </div>
        <div class="stat" style="align-items: flex-end;">
            <span class="stat-label">Best</span>
            <span id="best-score" class="stat-value">0</span>
        </div>
    </div>

    <div id="game-container">
        <div id="game-over-overlay">
            <h1 style="font-size: 40px; margin-bottom: 5px;">Game Over!</h1>
            <p id="final-score-text">Final Score: 0</p>
            <button class="btn" onclick="resetGame()">Try Again</button>
        </div>
    </div>

    <div class="evolution-guide" id="evolution-guide"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

<script>
    // --- HELPER FOR SVG GENERATION ---
    function makeSvg(content) {
        return `data:image/svg+xml;base64,${btoa(`
        <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            ${content}
        </svg>`)}`;
    }

    const ASSETS = {
        cherry: makeSvg(`
            <path d="M50 40 Q 55 20 70 15" stroke="#4a322d" stroke-width="4" fill="none" stroke-linecap="round"/>
            <path d="M70 15 Q 85 15 80 30 Q 65 30 70 15" fill="#4caf50" />
            <circle cx="50" cy="65" r="30" fill="#ff4d4d" />
            <circle cx="40" cy="55" r="8" fill="white" fill-opacity="0.3" />
            <circle cx="40" cy="65" r="3" fill="#333" />
            <circle cx="60" cy="65" r="3" fill="#333" />
            <path d="M45 75 Q 50 80 55 75" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round" />
            <circle cx="35" cy="70" r="4" fill="#ff7675" fill-opacity="0.6" />
            <circle cx="65" cy="70" r="4" fill="#ff7675" fill-opacity="0.6" />
        `),
        strawberry: makeSvg(`
            <path d="M50 15 L 50 5" stroke="#2d4a2d" stroke-width="4" stroke-linecap="round"/>
            <path d="M50 15 Q 30 15 25 40 Q 25 85 50 95 Q 75 85 75 40 Q 70 15 50 15" fill="#ff5e5e" />
            <path d="M35 25 Q 50 35 65 25 Q 55 10 50 20 Q 45 10 35 25" fill="#4caf50" />
            <circle cx="40" cy="45" r="3" fill="#333" />
            <circle cx="60" cy="45" r="3" fill="#333" />
            <path d="M43 55 Q 50 60 57 55" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round" />
            <circle cx="40" cy="70" r="1.5" fill="#fff" fill-opacity="0.5" />
            <circle cx="60" cy="65" r="1.5" fill="#fff" fill-opacity="0.5" />
            <circle cx="50" cy="80" r="1.5" fill="#fff" fill-opacity="0.5" />
        `),
        grape: makeSvg(`
            <path d="M50 20 L 50 10" stroke="#4a322d" stroke-width="3" />
            <circle cx="40" cy="35" r="12" fill="#9b59b6" />
            <circle cx="60" cy="35" r="12" fill="#8e44ad" />
            <circle cx="50" cy="55" r="12" fill="#9b59b6" />
            <circle cx="35" cy="55" r="12" fill="#8e44ad" />
            <circle cx="65" cy="55" r="12" fill="#8e44ad" />
            <circle cx="50" cy="75" r="12" fill="#9b59b6" />
            <circle cx="45" cy="55" r="2.5" fill="white" />
            <circle cx="55" cy="55" r="2.5" fill="white" />
            <path d="M47 62 Q 50 65 53 62" stroke="white" stroke-width="1.5" fill="none" stroke-linecap="round" />
        `),
        orange: makeSvg(`
            <circle cx="50" cy="50" r="45" fill="#f39c12" />
            <circle cx="50" cy="50" r="40" fill="#e67e22" />
            <circle cx="50" cy="12" r="6" fill="#27ae60" />
            <circle cx="40" cy="45" r="4" fill="#333" />
            <circle cx="60" cy="45" r="4" fill="#333" />
            <path d="M40 60 Q 50 75 60 60" fill="white" />
        `),
        persimmon: makeSvg(`
            <circle cx="50" cy="55" r="42" fill="#d35400" />
            <path d="M30 20 Q 50 35 70 20 L 60 10 Q 50 20 40 10 Z" fill="#2d4a2d" />
            <circle cx="40" cy="50" r="4" fill="#333" />
            <circle cx="60" cy="50" r="4" fill="#333" />
            <path d="M45 65 Q 50 70 55 65" stroke="#333" stroke-width="3" fill="none" stroke-linecap="round" />
        `),
        apple: makeSvg(`
            <path d="M50 45 Q 25 45 20 65 Q 20 95 50 95 Q 80 95 80 65 Q 75 45 50 45" fill="#e74c3c" />
            <path d="M50 45 L 50 30" stroke="#4a322d" stroke-width="5" />
            <path d="M50 35 Q 65 25 70 35 Q 65 45 50 35" fill="#2ecc71" />
            <circle cx="40" cy="65" r="5" fill="#333" />
            <circle cx="60" cy="65" r="5" fill="#333" />
            <path d="M40 78 Q 50 88 60 78" stroke="#333" stroke-width="3" fill="none" stroke-linecap="round" />
            <ellipse cx="35" cy="60" rx="8" ry="4" fill="white" fill-opacity="0.3" transform="rotate(-30, 35, 60)" />
        `),
        pear: makeSvg(`
            <path d="M50 20 Q 35 20 35 45 Q 35 60 25 75 Q 25 95 50 95 Q 75 95 75 75 Q 65 60 65 45 Q 65 20 50 20" fill="#f1c40f" />
            <path d="M50 20 L 50 10" stroke="#4a322d" stroke-width="4" />
            <circle cx="43" cy="50" r="4" fill="#333" />
            <circle cx="57" cy="50" r="4" fill="#333" />
            <path d="M45 65 H 55" stroke="#333" stroke-width="3" stroke-linecap="round" />
        `),
        peach: makeSvg(`
            <circle cx="50" cy="55" r="44" fill="#ffadad" />
            <path d="M50 15 Q 55 55 50 95" stroke="#ff8585" stroke-width="2" fill="none" />
            <path d="M50 15 Q 30 5 15 25" stroke="#2ecc71" stroke-width="4" fill="none" />
            <circle cx="40" cy="55" r="5" fill="#333" />
            <circle cx="60" cy="55" r="5" fill="#333" />
            <path d="M42 75 Q 50 82 58 75" stroke="#333" stroke-width="3" fill="none" stroke-linecap="round" />
            <circle cx="30" cy="65" r="6" fill="#ff8585" fill-opacity="0.5" />
            <circle cx="70" cy="65" r="6" fill="#ff8585" fill-opacity="0.5" />
        `),
        pineapple: makeSvg(`
            <rect x="25" y="40" width="50" height="55" rx="20" fill="#f1c40f" />
            <path d="M30 40 L 40 10 L 50 40 L 60 10 L 70 40" fill="#2ecc71" />
            <path d="M30 55 L 70 55 M30 70 L 70 70 M30 85 L 70 85 M40 40 L 40 95 M60 40 L 60 95" stroke="#d4ac0d" stroke-width="1" />
            <circle cx="40" cy="60" r="5" fill="#333" />
            <circle cx="60" cy="60" r="5" fill="#333" />
            <path d="M45 80 H 55" stroke="#333" stroke-width="4" stroke-linecap="round" />
        `),
        melon: makeSvg(`
            <circle cx="50" cy="50" r="45" fill="#a2de96" />
            <circle cx="50" cy="50" r="43" fill="none" stroke="#7ab36a" stroke-width="2" stroke-dasharray="5 5" />
            <path d="M50 10 Q 55 0 65 10" stroke="#4a322d" stroke-width="4" fill="none" />
            <circle cx="38" cy="45" r="6" fill="#333" />
            <circle cx="62" cy="45" r="6" fill="#333" />
            <path d="M40 65 Q 50 75 60 65" stroke="#333" stroke-width="4" fill="none" stroke-linecap="round" />
        `),
        watermelon: makeSvg(`
            <circle cx="50" cy="50" r="48" fill="#27ae60" />
            <path d="M50 2 A 48 48 0 0 1 50 98" fill="#2ecc71" />
            <path d="M10 30 Q 50 50 90 30 M10 70 Q 50 50 90 70" stroke="#1e8449" stroke-width="5" fill="none" stroke-linecap="round" />
            <circle cx="35" cy="45" r="8" fill="#333" />
            <circle cx="65" cy="45" r="8" fill="#333" />
            <rect x="40" y="65" width="20" height="10" rx="5" fill="#333" />
            <circle cx="30" cy="40" r="3" fill="white" />
            <circle cx="60" cy="40" r="3" fill="white" />
        `)
    };

    // --- CONFIGURATION ---
    const WIDTH = 400;
    const HEIGHT = 600;
    const SPAWN_Y = 60;
    const LOSS_THRESHOLD_Y = 110;

    const FRUITS = [
        { name: 'cherry', radius: 15, customImg: ASSETS.cherry, score: 2, color: '#ff4d4d' },
        { name: 'strawberry', radius: 22, customImg: ASSETS.strawberry, score: 4, color: '#ff7675' },
        { name: 'grape', radius: 32, customImg: ASSETS.grape, score: 8, color: '#a29bfe' },
        { name: 'orange', radius: 40, customImg: ASSETS.orange, score: 16, color: '#fab1a0' },
        { name: 'persimmon', radius: 52, customImg: ASSETS.persimmon, score: 32, color: '#e17055' },
        { name: 'apple', radius: 65, customImg: ASSETS.apple, score: 64, color: '#d63031' },
        { name: 'pear', radius: 78, customImg: ASSETS.pear, score: 128, color: '#fdcb6e' },
        { name: 'peach', radius: 92, customImg: ASSETS.peach, score: 256, color: '#ff7675' },
        { name: 'pineapple', radius: 108, customImg: ASSETS.pineapple, score: 512, color: '#ffeaa7' },
        { name: 'melon', radius: 125, customImg: ASSETS.melon, score: 1024, color: '#55efc4' },
        { name: 'watermelon', radius: 145, customImg: ASSETS.watermelon, score: 2048, color: '#00b894' }
    ];

    const imgCache = {};
    FRUITS.forEach(f => {
        const img = new Image();
        img.src = f.customImg;
        imgCache[f.name] = img;
    });

    const { Engine, Render, Runner, Bodies, Composite, Events, World, Body } = Matter;
    const engine = Engine.create({ gravity: { y: 1.5 } });
    const world = engine.world;

    const render = Render.create({
        element: document.getElementById('game-container'),
        engine: engine,
        options: { width: WIDTH, height: HEIGHT, wireframes: false, background: 'transparent' }
    });

    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('best-score');
    const nextPreviewEl = document.getElementById('next-fruit-preview');
    const overlay = document.getElementById('game-over-overlay');
    const finalScoreText = document.getElementById('final-score-text');

    let currentFruit = null;
    let nextFruitIndex = Math.floor(Math.random() * 4);
    let canDrop = true;
    let score = 0;
    let bestScore = localStorage.getItem('fruit-merge-best') || 0;
    let isGameOver = false;
    let gameOverCheckStartTime = null;

    bestScoreEl.innerText = bestScore;

    function initGuide() {
        const guideEl = document.getElementById('evolution-guide');
        guideEl.innerHTML = '';
        FRUITS.forEach((fruit, index) => {
            const item = document.createElement('div');
            item.className = 'evolution-item';
            item.innerHTML = `<img src="${fruit.customImg}" style="width:20px;height:20px;">`;
            if (index < FRUITS.length - 1) item.innerHTML += `<span class="arrow">▶</span>`;
            guideEl.appendChild(item);
        });
    }

    function createWalls() {
        const wallOptions = { isStatic: true, render: { fillStyle: '#5d4037' }, restitution: 0.2 };
        World.add(world, [
            Bodies.rectangle(WIDTH/2, HEIGHT + 10, WIDTH, 40, wallOptions),
            Bodies.rectangle(-10, HEIGHT/2, 20, HEIGHT, wallOptions),
            Bodies.rectangle(WIDTH + 10, HEIGHT/2, 20, HEIGHT, wallOptions)
        ]);
    }

    Events.on(render, 'afterRender', () => {
        const context = render.context;
        const bodies = Composite.allBodies(world);
        
        if (currentFruit && !isGameOver) {
            context.beginPath();
            context.setLineDash([5, 5]);
            context.moveTo(currentFruit.position.x, SPAWN_Y);
            context.lineTo(currentFruit.position.x, HEIGHT);
            context.strokeStyle = 'rgba(93, 64, 55, 0.2)';
            context.lineWidth = 2;
            context.stroke();
            context.setLineDash([]);
        }

        bodies.forEach(body => {
            if (body.fruitIndex !== undefined) {
                const { x, y } = body.position;
                const angle = body.angle;
                const fruit = FRUITS[body.fruitIndex];
                const isActiveInStack = !body.isStatic && body !== currentFruit && body.droppedAt && (Date.now() - body.droppedAt > 1000);
                const isDanger = isActiveInStack && (y - fruit.radius < LOSS_THRESHOLD_Y);
                
                context.save();
                context.translate(x, y);
                context.rotate(angle);
                
                context.beginPath();
                context.arc(0, 0, fruit.radius, 0, Math.PI * 2);
                
                if (isDanger) {
                    context.fillStyle = '#ff3e3e';
                    context.strokeStyle = '#fff';
                    context.lineWidth = 4;
                } else {
                    context.fillStyle = fruit.color;
                    context.strokeStyle = 'rgba(255,255,255,0.3)';
                    context.lineWidth = 3;
                }
                
                context.fill();
                context.stroke();

                if (imgCache[fruit.name]) {
                    const size = fruit.radius * 2.2;
                    context.drawImage(imgCache[fruit.name], -size/2, -size/2, size, size);
                }
                
                context.restore();
            }
        });

        context.beginPath();
        context.setLineDash([10, 10]);
        context.moveTo(0, LOSS_THRESHOLD_Y);
        context.lineTo(WIDTH, LOSS_THRESHOLD_Y);
        context.strokeStyle = 'rgba(214, 48, 49, 0.8)';
        context.lineWidth = 2;
        context.stroke();
        context.setLineDash([]);
    });

    function createFruit(x, y, index, isStatic = false) {
        const fruitDef = FRUITS[index];
        const fruit = Bodies.circle(x, y, fruitDef.radius, {
            restitution: 0.3, friction: 0.1, isStatic, isSensor: isStatic, label: 'fruit', render: { visible: false }
        });
        fruit.fruitIndex = index;
        if (!isStatic) fruit.droppedAt = Date.now(); 
        return fruit;
    }

    function spawnCurrentFruit() {
        if (isGameOver) return;
        const index = nextFruitIndex;
        nextFruitIndex = Math.floor(Math.random() * 4);
        
        const nextFruit = FRUITS[nextFruitIndex];
        nextPreviewEl.innerHTML = `<img src="${nextFruit.customImg}">`;

        currentFruit = createFruit(WIDTH / 2, SPAWN_Y, index, true);
        World.add(world, currentFruit);
        canDrop = true;
    }

    function handleInput(clientX) {
        if (!currentFruit || !canDrop || isGameOver) return;
        const rect = render.canvas.getBoundingClientRect();
        let x = (clientX - rect.left) * (WIDTH / rect.width);
        const radius = FRUITS[currentFruit.fruitIndex].radius;
        x = Math.max(radius + 5, Math.min(WIDTH - radius - 5, x));
        Body.setPosition(currentFruit, { x, y: SPAWN_Y });
    }

    function dropFruit() {
        if (!currentFruit || !canDrop || isGameOver) return;
        canDrop = false;
        currentFruit.isSensor = false;
        currentFruit.droppedAt = Date.now(); 
        Body.setStatic(currentFruit, false);
        currentFruit = null;
        setTimeout(spawnCurrentFruit, 800);
    }

    render.canvas.addEventListener('mousemove', (e) => handleInput(e.clientX));
    render.canvas.addEventListener('click', (e) => { handleInput(e.clientX); dropFruit(); });
    render.canvas.addEventListener('touchstart', (e) => handleInput(e.touches[0].clientX), { passive: false });
    render.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e.touches[0].clientX); }, { passive: false });
    render.canvas.addEventListener('touchend', dropFruit, { passive: false });

    Events.on(engine, 'collisionStart', (event) => {
        event.pairs.forEach(({ bodyA, bodyB }) => {
            if (bodyA.fruitIndex !== undefined && bodyB.fruitIndex !== undefined && bodyA.fruitIndex === bodyB.fruitIndex) {
                if (bodyA.fruitIndex >= FRUITS.length - 1) return;
                if (!Composite.get(world, bodyA.id, 'body') || !Composite.get(world, bodyB.id, 'body')) return;
                const nextIndex = bodyA.fruitIndex + 1;
                const newX = (bodyA.position.x + bodyB.position.x) / 2;
                const newY = (bodyA.position.y + bodyB.position.y) / 2;
                World.remove(world, [bodyA, bodyB]);
                World.add(world, createFruit(newX, newY, nextIndex));
                score += FRUITS[nextIndex].score;
                scoreEl.innerText = score;
                if (score > bestScore) {
                    bestScore = score;
                    bestScoreEl.innerText = bestScore;
                    localStorage.setItem('fruit-merge-best', bestScore);
                }
            }
        });
    });

    Events.on(engine, 'afterUpdate', () => {
        if (isGameOver) return;
        const bodies = Composite.allBodies(world).filter(b => b.fruitIndex !== undefined && !b.isStatic && b.droppedAt && (Date.now() - b.droppedAt > 1500));
        const fruitAboveLine = bodies.some(b => b.position.y - FRUITS[b.fruitIndex].radius < LOSS_THRESHOLD_Y);
        if (fruitAboveLine) {
            if (!gameOverCheckStartTime) gameOverCheckStartTime = Date.now();
            else if (Date.now() - gameOverCheckStartTime > 2000) triggerGameOver();
        } else gameOverCheckStartTime = null;
    });

    function triggerGameOver() {
        isGameOver = true;
        overlay.style.display = 'flex';
        finalScoreText.innerText = `Final Score: ${score}`;
    }

    function resetGame() {
        World.clear(world, false);
        createWalls();
        score = 0;
        scoreEl.innerText = '0';
        isGameOver = false;
        gameOverCheckStartTime = null;
        overlay.style.display = 'none';
        spawnCurrentFruit();
    }

    initGuide();
    createWalls();
    Render.run(render);
    Runner.run(Runner.create(), engine);
    spawnCurrentFruit();
</script>
</body>
</html>
